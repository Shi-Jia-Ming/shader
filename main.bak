unsafe fn create_line() -> u32 {
    let vertices: [f32; 12] = [
        // 起始点 (x1, y1, z1)
        -0.2, -0.2, 0.0, // 终止点 (x2, y2, z2)
        -0.2, 0.2, 0.0, 0.2, 0.2, 0.0, 0.2, -0.2, 0.0,
    ];

    let mut vbo: u32 = 0;

    // 创建顶点缓冲对象
    unsafe {
        gl::GenBuffers(1, &mut vbo);
        gl::BindBuffer(gl::ARRAY_BUFFER, vbo);
        gl::BufferData(
            gl::ARRAY_BUFFER,
            (vertices.len() * std::mem::size_of::<f32>()) as isize,
            vertices.as_ptr() as *const _,
            gl::STATIC_DRAW,
        );
    }

    // 创建顶点数组对象
    let mut vao: u32 = 0;
    unsafe {
        gl::GenVertexArrays(1, &mut vao);
        gl::BindVertexArray(vao);

        gl::VertexAttribPointer(
            0,
            3,
            gl::FLOAT,
            gl::FALSE,
            3 * std::mem::size_of::<f32>() as i32,
            ptr::null(),
        );
        gl::EnableVertexAttribArray(0);

        gl::BindBuffer(gl::ARRAY_BUFFER, 0);
        gl::BindVertexArray(0);
    }

    vao
}

fn main() {
    // 创建一个 OpenGL 上下文
    let event_loop = glutin::event_loop::EventLoop::new();
    let window_builder = glutin::window::WindowBuilder::new().with_title("OpenGL in Rust");

    let windowed_context = glutin::ContextBuilder::new()
        .with_gl(glutin::GlRequest::Specific(glutin::Api::OpenGl, (4, 6)))
        .with_gl_profile(glutin::GlProfile::Core)
        .with_vsync(true)
        .build_windowed(window_builder, &event_loop)
        .unwrap();

    let windowed_context = unsafe {
        let windowed_context = windowed_context.make_current().unwrap();
        gl::load_with(|symbol| windowed_context.get_proc_address(symbol) as *const _);

        windowed_context
    };

    // 读取并编译着色器
    let vertex_shader_source = load_shader_from_file("src/vertex_shader.glsl");
    let fragment_shader_source = load_shader_from_file("src/fragment_shader.glsl");

    let vertex_shader = compile_shader(&vertex_shader_source, gl::VERTEX_SHADER);
    let fragment_shader = compile_shader(&fragment_shader_source, gl::FRAGMENT_SHADER);

    // 链接着色器
    let shader_program = link_program(vertex_shader, fragment_shader);

    // 初始化四边形顶点数据
    let vao = unsafe { create_line() };

    // 初始化帧缓冲区
    let frame_buffer = unsafe { create_frame_buffer() };

    // 渲染循环
    event_loop.run(move |event, _, control_flow| {
        use glutin::event::{Event, WindowEvent};
        use glutin::event_loop::ControlFlow;

        *control_flow = ControlFlow::Wait;

        match event {
            Event::WindowEvent { event, .. } => match event {
                WindowEvent::CloseRequested => {
                    *control_flow = ControlFlow::Exit;
                }
                _ => (),
            },
            Event::MainEventsCleared => {
                // 清屏
                unsafe {
                    // 渲染场景到帧缓冲区
                    gl::BindFramebuffer(gl::FRAMEBUFFER, frame_buffer);
                    gl::ClearColor(0.1, 0.1, 0.1, 1.0);
                    gl::Clear(gl::COLOR_BUFFER_BIT | gl::DEPTH_BUFFER_BIT);

                    // gl::ClearColor(0.9, 0.9, 0.9, 0.0);
                    // gl::Clear(gl::COLOR_BUFFER_BIT);

                    // 绘制三角形
                    gl::BindVertexArray(vao);
                    // gl::DrawArrays(gl::LINES, 1, 2);
                    // gl::DrawArrays(gl::POINTS, 4, 1);
                    gl::DrawArrays(gl::TRIANGLE_FAN, 0, 4);

                    
                    // 切换回默认帧缓冲区
                    gl::BindFramebuffer(gl::FRAMEBUFFER, 0);
                    // gl::ClearColor(0.2, 0.3, 0.3, 1.0);
                    gl::Clear(gl::COLOR_BUFFER_BIT);

                    // 使用着色器程序
                    gl::UseProgram(shader_program);
                    gl::BindVertexArray(vao);
                    gl::BindTexture(gl::TEXTURE_2D, frame_buffer);

                    gl::DrawArrays(gl::TRIANGLE_FAN, 0, 4);
                }

                // 交换缓冲区
                windowed_context.swap_buffers().unwrap();
            }
            _ => (),
        }
    });
}
